<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Americano Beach Tennis - Rotations & Scores</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f4f4f8;
      color: #222;
    }
    header {
      background: linear-gradient(135deg,#1f7ac4,#00a6d6);
      color: white;
      padding: 1rem 1.3rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    header .logo-wrap {
      display:flex;
      align-items:center;
      justify-content:center;
    }
    header svg {
      height: 48px;
      width: 48px;
    }
    header h1 {
      margin: 0;
      font-size: 1.4rem;
    }
    header p {
      margin: 0.3rem 0 0;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    main {
      padding: 1rem;
      max-width: 1100px;
      margin: 0 auto 2rem;
    }
    h2 {
      margin-top: 1.2rem;
      font-size: 1.2rem;
    }
    .card {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    }
    .players-list {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem .75rem;
      font-size: 0.9rem;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: #eef5ff;
    }
    .badge span.role {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-right: 0.35rem;
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
      color: white;
    }
    .badge span.role.H { background: #1f7ac4; }
    .badge span.role.F { background: #e84a8a; }
    .badge span.name { font-weight: 500; }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.85rem;
    }
    th, td {
      border-bottom: 1px solid #e0e0e0;
      padding: 0.35rem 0.4rem;
      text-align: left;
    }
    th {
      background: #f0f4ff;
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    tr:nth-child(even) td { background: #fafafa; }
    input[type="number"] {
      width: 3rem;
      padding: 0.1rem 0.2rem;
      font-size: 0.8rem;
    }
    select {
      font-size: 0.8rem;
      padding: 0.1rem 0.2rem;
      max-width: 130px;
    }
    .matches-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
      justify-content: space-between;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 0.4rem 0.9rem;
      font-size: 0.8rem;
      cursor: pointer;
      background: #1f7ac4;
      color: white;
      font-weight: 500;
    }
    button.secondary { background: #e0e0e0; color: #333; }
    button.danger { background: #e05050; }
    button:disabled { opacity: 0.5; cursor: default; }
    .standings-container {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr) minmax(0, 1fr);
      gap: 0.75rem;
    }
    @media (max-width: 900px) {
      .standings-container {
        grid-template-columns: minmax(0,1fr);
      }
    }
    .pill {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #eef2ff;
      font-size: 0.75rem;
      margin-left: 0.4rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.25rem;
    }
    .rotation-header {
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:0.5rem;
      margin-bottom:0.5rem;
    }
    .rotation-header select {
      min-width: 80px;
    }
  </style>
</head>

<body>
<header>
  <div class="logo-wrap">
    <!-- Logo Club B -->
    <svg viewBox="0 0 100 100">
      <defs>
        <linearGradient id="gradB" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#ffd54f"/>
          <stop offset="100%" stop-color="#ff8f00"/>
        </linearGradient>
      </defs>
      <circle cx="50" cy="50" r="45" fill="url(#gradB)" />
      <text x="50" y="55"
            text-anchor="middle"
            dominant-baseline="middle"
            font-size="40"
            font-family="system-ui, sans-serif"
            fill="#222"
            font-weight="700">
        B
      </text>
    </svg>
  </div>
  <div>
    <h1>Americano Beach Tennis ‚Äì Club B</h1>
    <p>Rotations pr√©-g√©n√©r√©es, saisie des scores & classements automatiques.</p>
  </div>
</header>

<main>
  <!-- Joueurs -->
  <section class="card">
    <h2>üë• Joueurs</h2>
    <p style="margin-top:0;">Liste des participants du tournoi mixte.</p>
    <div class="players-list" id="playersList"></div>
  </section>

  <!-- Matches par rotation -->
  <section class="card">
    <h2>üèì Matches par rotation</h2>
    <div class="rotation-header">
      <div>
        Rotation :
        <select id="rotationSelect"></select>
      </div>
      <button id="clearScoresBtn" class="secondary">üßπ Effacer tous les scores</button>
    </div>
    <div class="hint">
      Planning d√©j√† rempli (toutes les rotations).<br>
      Tu n'as plus qu'√† saisir les scores : les classements se mettent √† jour automatiquement.
    </div>
    <div style="max-height: 420px; overflow:auto; border:1px solid #e0e0e0; border-radius:8px;">
      <table id="matchesTable">
        <thead>
          <tr>
            <th>Court</th>
            <th>H A</th>
            <th>F A</th>
            <th>H B</th>
            <th>F B</th>
            <th>Pts A</th>
            <th>Pts B</th>
          </tr>
        </thead>
        <tbody>
          <!-- lignes g√©n√©r√©es en JS -->
        </tbody>
      </table>
    </div>
  </section>

  <!-- Classements -->
  <section class="card">
    <h2>üìä Classements</h2>
    <p style="margin-top:0;">Somme des points marqu√©s dans toutes les √©quipes o√π le joueur appara√Æt.</p>
    <div class="standings-container">
      <div>
        <h3>üèÜ Global</h3>
        <table id="tableGlobal">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Joueur</th>
              <th>Sexe</th>
              <th>Points</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h3>üë® Hommes</h3>
        <table id="tableMen">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Joueur</th>
              <th>Points</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h3>üë© Femmes</h3>
        <table id="tableWomen">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Joueur</th>
              <th>Points</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>
</main>

<script>
/* ==== JOUEURS ==== */
const MEN = [
  "Quentin S",
  "Jenda",
  "Lo√Øc Suzini",
  "Lo√Øc Kourou",
  "Jules",
  "Andreas",
  "Romain",
  "Quentin C",
  "Patrice"
];

const WOMEN = [
  "Karine",
  "Manon",
  "√âmilie",
  "Marine",
  "Camille",
  "Tamily",
  "Eliana",
  "Erika",
  "Myl√®ne",
  "Guylmour",
  "Emma",
  "Melanie"
];

const PLAYERS = [
  ...MEN.map(name => ({ name, sex: "H" })),
  ...WOMEN.map(name => ({ name, sex: "F" })),
];

const STORAGE_KEY = "americano_matches_preplanned_v1";

let matches = [];
let nextId = 1;

/* ==== LISTE JOUEURS ==== */
function renderPlayers() {
  const container = document.getElementById("playersList");
  container.innerHTML = "";
  PLAYERS.forEach(p => {
    const div = document.createElement("div");
    div.className = "badge";
    div.innerHTML = `
      <span class="role ${p.sex}">${p.sex}</span>
      <span class="name">${p.name}</span>
    `;
    container.appendChild(div);
  });
}

/* ==== G√âN√âRATION AUTOMATIQUE DU PLANNING ====
   Objectif :
   - chaque homme joue avec chaque femme exactement une fois
   - on forme des matchs (2 √©quipes) avec joueurs distincts
   - max 4 matchs par rotation
*/
function generateInitialMatches() {
  const allPairs = [];
  for (let i = 0; i < MEN.length; i++) {
    for (let j = 0; j < WOMEN.length; j++) {
      allPairs.push({ m: i, w: j });
    }
  }
  let unassigned = allPairs.slice();
  const manUse = Array(MEN.length).fill(0);
  const womanUse = Array(WOMEN.length).fill(0);

  const rotations = []; // chaque √©l√©ment = liste de matchs, match = [pairA, pairB]
  const maxMatchesPerRotation = 4;

  while (unassigned.length > 0) {
    const usedMen = new Set();
    const usedWomen = new Set();
    const matchesRot = [];

    while (matchesRot.length < maxMatchesPerRotation && unassigned.length > 0) {
      const candPairs = unassigned.slice().sort((a, b) => {
        const sa = manUse[a.m] + womanUse[a.w];
        const sb = manUse[b.m] + womanUse[b.w];
        if (sa !== sb) return sa - sb;
        if (manUse[a.m] !== manUse[b.m]) return manUse[a.m] - manUse[b.m];
        return womanUse[a.w] - womanUse[b.w];
      });

      let foundMatch = false;

      for (let ia = 0; ia < candPairs.length; ia++) {
        const pA = candPairs[ia];
        const mA = pA.m, wA = pA.w;
        if (usedMen.has(mA) || usedWomen.has(wA)) continue;

        for (let ib = ia + 1; ib < candPairs.length; ib++) {
          const pB = candPairs[ib];
          const mB = pB.m, wB = pB.w;
          if (mB === mA || wB === wA) continue;
          if (usedMen.has(mB) || usedWomen.has(wB)) continue;

          // On a un match valide
          matchesRot.push([pA, pB]);

          // enlever les paires de unassigned
          unassigned = unassigned.filter(p =>
            !((p.m === mA && p.w === wA) || (p.m === mB && p.w === wB))
          );

          usedMen.add(mA); usedMen.add(mB);
          usedWomen.add(wA); usedWomen.add(wB);
          manUse[mA]++; manUse[mB]++;
          womanUse[wA]++; womanUse[wB]++;

          foundMatch = true;
          break;
        }
        if (foundMatch) break;
      }

      if (!foundMatch) break;
    }

    if (matchesRot.length > 0) {
      rotations.push(matchesRot);
    } else {
      // s√©curit√© pour √©viter boucle infinie (ne devrait pas arriver ici)
      break;
    }
  }

  const result = [];
  let id = 1;
  for (let r = 0; r < rotations.length; r++) {
    const rot = rotations[r];
    for (let c = 0; c < rot.length; c++) {
      const [pA, pB] = rot[c];
      result.push({
        id: id++,
        rotation: r + 1,
        court: c + 1,
        manA: MEN[pA.m],
        womanA: WOMEN[pA.w],
        manB: MEN[pB.m],
        womanB: WOMEN[pB.w],
        ptsA: "",
        ptsB: ""
      });
    }
  }
  return result;
}

/* ==== ROTATIONS ==== */
function getAllRotations() {
  const set = new Set(matches.map(m => m.rotation));
  const list = Array.from(set);
  list.sort((a,b)=>a-b);
  return list;
}

function renderRotationSelect() {
  const sel = document.getElementById("rotationSelect");
  const rotations = getAllRotations();
  const current = Number(sel.value) || rotations[0] || 1;
  sel.innerHTML = rotations.map(r =>
    `<option value="${r}">Rotation ${r}</option>`
  ).join("");
  sel.value = current;
}

/* ==== LOCALSTORAGE ==== */
function saveMatches() {
  const payload = { matches, nextId };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
}

function loadMatches() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      matches = generateInitialMatches();
      nextId = matches.length + 1;
      return;
    }
    const parsed = JSON.parse(raw);
    if (parsed && Array.isArray(parsed.matches)) {
      matches = parsed.matches;
      nextId = parsed.nextId || (matches.reduce((mx,m)=>Math.max(mx,m.id),0)+1);
    } else {
      matches = generateInitialMatches();
      nextId = matches.length + 1;
    }
  } catch (e) {
    console.warn("Erreur stockage, nouvel horaire g√©n√©r√©", e);
    matches = generateInitialMatches();
    nextId = matches.length + 1;
  }
}

/* ==== TABLEAU MATCHES (rotation courante) ==== */
function renderMatchesTable() {
  const tbody = document.querySelector("#matchesTable tbody");
  const sel = document.getElementById("rotationSelect");
  const currentRot = Number(sel.value) || 1;

  const list = matches
    .filter(m => m.rotation === currentRot)
    .sort((a,b)=> (a.court||0) - (b.court||0) || a.id - b.id);

  tbody.innerHTML = "";

  list.forEach(m => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${m.court || ""}</td>
      <td>${m.manA}</td>
      <td>${m.womanA}</td>
      <td>${m.manB}</td>
      <td>${m.womanB}</td>
      <td>
        <input type="number" min="0"
               data-id="${m.id}" data-field="ptsA"
               value="${m.ptsA !== "" ? m.ptsA : ""}">
      </td>
      <td>
        <input type="number" min="0"
               data-id="${m.id}" data-field="ptsB"
               value="${m.ptsB !== "" ? m.ptsB : ""}">
      </td>
    `;
    tbody.appendChild(tr);
  });

  tbody.querySelectorAll('input[type="number"]').forEach(inp => {
    inp.addEventListener("input", e => {
      const id = Number(e.target.dataset.id);
      const field = e.target.dataset.field;
      const match = matches.find(m => m.id === id);
      if (!match) return;
      const v = e.target.value;
      match[field] = v === "" ? "" : Number(v);
      saveMatches();
      recomputeStandings();
    });
  });
}

/* ==== SCORES ==== */
function clearAllScores() {
  if (!confirm("Effacer tous les scores (les matchs restent) ?")) return;
  matches = matches.map(m => ({
    ...m,
    ptsA: "",
    ptsB: ""
  }));
  saveMatches();
  renderMatchesTable();
  recomputeStandings();
}

/* ==== CLASSEMENTS ==== */
function recomputeStandings() {
  const points = {};
  PLAYERS.forEach(p => { points[p.name] = 0; });

  matches.forEach(m => {
    if (
      m.manA && m.womanA && m.manB && m.womanB &&
      m.ptsA !== "" && m.ptsB !== "" &&
      !isNaN(m.ptsA) && !isNaN(m.ptsB)
    ) {
      const a = Number(m.ptsA);
      const b = Number(m.ptsB);
      if (!isNaN(a)) {
        points[m.manA] += a;
        points[m.womanA] += a;
      }
      if (!isNaN(b)) {
        points[m.manB] += b;
        points[m.womanB] += b;
      }
    }
  });

  const all = PLAYERS.map(p => ({
    name: p.name,
    sex: p.sex,
    pts: points[p.name] || 0
  }));

  const global = [...all].sort((x,y)=> y.pts - x.pts || x.name.localeCompare(y.name));
  const men    = global.filter(p => p.sex === "H");
  const women  = global.filter(p => p.sex === "F");

  fillTable("#tableGlobal", global, true);
  fillTable("#tableMen", men, false);
  fillTable("#tableWomen", women, false);
}

function fillTable(selector, list, withSex) {
  const tbody = document.querySelector(selector + " tbody");
  tbody.innerHTML = "";
  list.forEach((p, idx) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${idx+1}</td>
      <td>${p.name}</td>
      ${withSex ? `<td>${p.sex}</td>` : ""}
      <td>${p.pts}</td>
    `;
    tbody.appendChild(tr);
  });
}

/* ==== INIT ==== */
document.addEventListener("DOMContentLoaded", () => {
  renderPlayers();
  loadMatches();
  renderRotationSelect();
  renderMatchesTable();
  recomputeStandings();

  document.getElementById("rotationSelect").addEventListener("change", () => {
    renderMatchesTable();
  });

  document.getElementById("clearScoresBtn").addEventListener("click", clearAllScores);
});
</script>
</body>
</html>