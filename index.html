<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Americano Beach Tennis - Rotations & Scores</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 0;
      background: #f4f4f8;
      color: #222;
    }
    header {
      background: linear-gradient(135deg,#1f7ac4,#00a6d6);
      color: white;
      padding: 1rem 1.3rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    header .logo-wrap {
      display:flex;
      align-items:center;
      justify-content:center;
    }
    header svg {
      height: 48px;
      width: 48px;
    }
    header h1 {
      margin: 0;
      font-size: 1.4rem;
    }
    header p {
      margin: 0.3rem 0 0;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    main {
      padding: 1rem;
      max-width: 1100px;
      margin: 0 auto 2rem;
    }
    h2 {
      margin-top: 1.2rem;
      font-size: 1.2rem;
    }
    .card {
      background: white;
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
    }
    .players-list {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem .75rem;
      font-size: 0.9rem;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: #eef5ff;
    }
    .badge span.role {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-right: 0.35rem;
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
      color: white;
    }
    .badge span.role.H { background: #1f7ac4; }
    .badge span.role.F { background: #e84a8a; }
    .badge span.name { font-weight: 500; }
    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.85rem;
    }
    th, td {
      border-bottom: 1px solid #e0e0e0;
      padding: 0.35rem 0.4rem;
      text-align: left;
    }
    th {
      background: #f0f4ff;
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    tr:nth-child(even) td { background: #fafafa; }
    input[type="number"] {
      width: 3rem;
      padding: 0.1rem 0.2rem;
      font-size: 0.8rem;
    }
    select {
      font-size: 0.8rem;
      padding: 0.1rem 0.2rem;
      max-width: 120px;
    }
    .matches-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
      justify-content: space-between;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 0.4rem 0.9rem;
      font-size: 0.8rem;
      cursor: pointer;
      background: #1f7ac4;
      color: white;
      font-weight: 500;
    }
    button.secondary { background: #e0e0e0; color: #333; }
    button.danger { background: #e05050; }
    button:disabled { opacity: 0.5; cursor: default; }
    .standings-container {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr) minmax(0, 1fr);
      gap: 0.75rem;
    }
    @media (max-width: 900px) {
      .standings-container {
        grid-template-columns: minmax(0,1fr);
      }
    }
    .pill {
      display: inline-block;
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #eef2ff;
      font-size: 0.75rem;
      margin-left: 0.4rem;
    }
    .hint {
      font-size: 0.75rem;
      color: #666;
      margin-top: 0.25rem;
    }
    .rotation-header {
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:0.5rem;
      margin-bottom:0.5rem;
    }
    .rotation-header select {
      min-width: 80px;
    }
  </style>
</head>

<body>
<header>
  <div class="logo-wrap">
    <!-- Logo Club B : simple rond avec B, tu pourras le remplacer plus tard -->
    <svg viewBox="0 0 100 100">
      <defs>
        <linearGradient id="gradB" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#ffd54f"/>
          <stop offset="100%" stop-color="#ff8f00"/>
        </linearGradient>
      </defs>
      <circle cx="50" cy="50" r="45" fill="url(#gradB)" />
      <text x="50" y="55"
            text-anchor="middle"
            dominant-baseline="middle"
            font-size="40"
            font-family="system-ui, sans-serif"
            fill="#222"
            font-weight="700">
        B
      </text>
    </svg>
  </div>
  <div>
    <h1>Americano Beach Tennis ‚Äì Club B</h1>
    <p>Rotations, saisie des scores et classements automatiques.</p>
  </div>
</header>

<main>
  <!-- Joueurs -->
  <section class="card">
    <h2>üë• Joueurs</h2>
    <p style="margin-top:0;">Liste des participants du tournoi mixte.</p>
    <div class="players-list" id="playersList"></div>
  </section>

  <!-- Matches par rotation -->
  <section class="card">
    <h2>üèì Matches par rotation</h2>
    <div class="rotation-header">
      <div>
        Rotation :
        <select id="rotationSelect"></select>
      </div>
      <button id="addMatchBtn">‚ûï Ajouter un match √† cette rotation</button>
      <button id="clearScoresBtn" class="secondary">üßπ Effacer tous les scores</button>
    </div>
    <div class="hint">
      1) Avant le tournoi : d√©finis les matchs (noms des √©quipes) rotation par rotation.<br>
      2) Pendant le tournoi : tu n'as plus qu'√† saisir les scores, les √©quipes restent en place (sauvegarde dans le navigateur).
    </div>
    <div style="max-height: 420px; overflow:auto; border:1px solid #e0e0e0; border-radius:8px;">
      <table id="matchesTable">
        <thead>
          <tr>
            <th>Court</th>
            <th>H A</th>
            <th>F A</th>
            <th>H B</th>
            <th>F B</th>
            <th>Pts A</th>
            <th>Pts B</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          <!-- lignes g√©n√©r√©es en JS -->
        </tbody>
      </table>
    </div>
  </section>

  <!-- Classements -->
  <section class="card">
    <h2>üìä Classements</h2>
    <p style="margin-top:0;">Somme des points marqu√©s dans toutes les √©quipes o√π le joueur appara√Æt.</p>
    <div class="standings-container">
      <div>
        <h3>üèÜ Global</h3>
        <table id="tableGlobal">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Joueur</th>
              <th>Sexe</th>
              <th>Points</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h3>üë® Hommes</h3>
        <table id="tableMen">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Joueur</th>
              <th>Points</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <h3>üë© Femmes</h3>
        <table id="tableWomen">
          <thead>
            <tr>
              <th>Rang</th>
              <th>Joueur</th>
              <th>Points</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>
</main>

<script>
/* ==== CONFIG JOUEURS ==== */
const MEN = [
  "Quentin S",
  "Jenda",
  "Lo√Øc Suzini",
  "Lo√Øc Kourou",
  "Jules",
  "Andreas",
  "Romain",
  "Quentin C",
  "Patrice"
];

const WOMEN = [
  "Karine",
  "Manon",
  "√âmilie",
  "Marine",
  "Camille",
  "Tamily",
  "Eliana",
  "Erika",
  "Myl√®ne",
  "Guylmour",
  "Emma",
  "Melanie"
];

const PLAYERS = [
  ...MEN.map(name => ({ name, sex: "H" })),
  ...WOMEN.map(name => ({ name, sex: "F" })),
];

const STORAGE_KEY = "americano_matches_by_rotation_v1";

/* ==== √âTAT DES MATCHS ====
   Chaque match : {
     id, rotation, court,
     manA, womanA, manB, womanB,
     ptsA, ptsB
   }
*/
let matches = [];
let nextId = 1;

/* ==== UTILITAIRES ==== */
function createPlayerOptions(list) {
  const opts = ['<option value=""></option>'];
  list.forEach(name => {
    opts.push(`<option value="${name}">${name}</option>`);
  });
  return opts.join("");
}

const OPTIONS_MEN = createPlayerOptions(MEN);
const OPTIONS_WOMEN = createPlayerOptions(WOMEN);

/* ==== RENDU JOUEURS ==== */
function renderPlayers() {
  const container = document.getElementById("playersList");
  container.innerHTML = "";
  PLAYERS.forEach(p => {
    const div = document.createElement("div");
    div.className = "badge";
    div.innerHTML = `
      <span class="role ${p.sex}">${p.sex}</span>
      <span class="name">${p.name}</span>
    `;
    container.appendChild(div);
  });
}

/* ==== GESTION ROTATIONS ==== */
function getAllRotations() {
  const set = new Set(matches.map(m => m.rotation));
  if (set.size === 0) {
    // par d√©faut, on cr√©e 1..14
    for (let r = 1; r <= 14; r++) set.add(r);
  }
  return Array.from(set).sort((a,b)=>a-b);
}

function renderRotationSelect() {
  const sel = document.getElementById("rotationSelect");
  const rotations = getAllRotations();
  const current = Number(sel.value) || rotations[0] || 1;
  sel.innerHTML = rotations.map(r =>
    `<option value="${r}">Rotation ${r}</option>`
  ).join("");
  sel.value = current;
}

/* ==== MATCHES : CRUD ==== */
function addMatchToRotation(rot) {
  matches.push({
    id: nextId++,
    rotation: rot,
    court: "",
    manA: "",
    womanA: "",
    manB: "",
    womanB: "",
    ptsA: "",
    ptsB: ""
  });
  saveMatches();
  renderRotationSelect();
  renderMatchesTable();
  recomputeStandings();
}

function deleteMatch(id) {
  if (!confirm("Supprimer ce match ?")) return;
  matches = matches.filter(m => m.id !== id);
  saveMatches();
  renderRotationSelect();
  renderMatchesTable();
  recomputeStandings();
}

/* ==== LOCALSTORAGE ==== */
function saveMatches() {
  const payload = { matches, nextId };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
}

function loadMatches() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      matches = [];
      nextId = 1;
      return;
    }
    const parsed = JSON.parse(raw);
    if (parsed && Array.isArray(parsed.matches)) {
      matches = parsed.matches;
      nextId = parsed.nextId || (matches.reduce((mx,m)=>Math.max(mx,m.id),0)+1);
    } else {
      matches = [];
      nextId = 1;
    }
  } catch (e) {
    console.warn("Erreur lecture stockage local", e);
    matches = [];
    nextId = 1;
  }
}

/* ==== RENDU TABLEAU MATCHES POUR LA ROTATION COURANTE ==== */
function renderMatchesTable() {
  const tbody = document.querySelector("#matchesTable tbody");
  const sel = document.getElementById("rotationSelect");
  const currentRot = Number(sel.value) || 1;

  const list = matches
    .filter(m => m.rotation === currentRot)
    .sort((a,b)=> (a.court||0) - (b.court||0) || a.id - b.id);

  tbody.innerHTML = "";

  list.forEach(m => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>
        <input type="number" min="1" max="8"
               data-id="${m.id}" data-field="court"
               value="${m.court !== "" ? m.court : ""}">
      </td>
      <td>
        <select data-id="${m.id}" data-field="manA">
          ${OPTIONS_MEN}
        </select>
      </td>
      <td>
        <select data-id="${m.id}" data-field="womanA">
          ${OPTIONS_WOMEN}
        </select>
      </td>
      <td>
        <select data-id="${m.id}" data-field="manB">
          ${OPTIONS_MEN}
        </select>
      </td>
      <td>
        <select data-id="${m.id}" data-field="womanB">
          ${OPTIONS_WOMEN}
        </select>
      </td>
      <td>
        <input type="number" min="0"
               data-id="${m.id}" data-field="ptsA"
               value="${m.ptsA !== "" ? m.ptsA : ""}">
      </td>
      <td>
        <input type="number" min="0"
               data-id="${m.id}" data-field="ptsB"
               value="${m.ptsB !== "" ? m.ptsB : ""}">
      </td>
      <td>
        <button class="danger" data-delete="${m.id}">‚úñ</button>
      </td>
    `;
    tbody.appendChild(tr);
  });

  // Appliquer les valeurs dans les <select>
  list.forEach(m => {
    const row = tbody.querySelector(`button[data-delete="${m.id}"]`).closest("tr");
    row.querySelector('select[data-field="manA"]').value = m.manA || "";
    row.querySelector('select[data-field="womanA"]').value = m.womanA || "";
    row.querySelector('select[data-field="manB"]').value = m.manB || "";
    row.querySelector('select[data-field="womanB"]').value = m.womanB || "";
  });

  // √âcouteurs
  tbody.querySelectorAll("select").forEach(selEl => {
    selEl.addEventListener("change", e => {
      const id = Number(e.target.dataset.id);
      const field = e.target.dataset.field;
      const match = matches.find(m => m.id === id);
      if (!match) return;
      match[field] = e.target.value || "";
      saveMatches();
      // pas besoin de recompute standings si noms seulement
    });
  });

  tbody.querySelectorAll('input[type="number"]').forEach(inp => {
    inp.addEventListener("input", e => {
      const id = Number(e.target.dataset.id);
      const field = e.target.dataset.field;
      const match = matches.find(m => m.id === id);
      if (!match) return;
      const v = e.target.value;
      if (field === "court") {
        match[field] = v === "" ? "" : Number(v);
      } else {
        match[field] = v === "" ? "" : Number(v);
      }
      saveMatches();
      recomputeStandings();
    });
  });

  tbody.querySelectorAll("button[data-delete]").forEach(btn => {
    btn.addEventListener("click", e => {
      const id = Number(e.target.dataset.delete);
      deleteMatch(id);
    });
  });
}

/* ==== EFFACER SCORES ==== */
function clearAllScores() {
  if (!confirm("Effacer tous les scores (les matchs restent) ?")) return;
  matches = matches.map(m => ({
    ...m,
    ptsA: "",
    ptsB: ""
  }));
  saveMatches();
  renderMatchesTable();
  recomputeStandings();
}

/* ==== CLASSEMENTS ==== */
function recomputeStandings() {
  const points = {};
  PLAYERS.forEach(p => { points[p.name] = 0; });

  matches.forEach(m => {
    if (m.manA && m.womanA && m.manB && m.womanB &&
        m.ptsA !== "" && m.ptsB !== "" &&
        !isNaN(m.ptsA) && !isNaN(m.ptsB)) {
      const a = Number(m.ptsA);
      const b = Number(m.ptsB);
      if (!isNaN(a)) {
        points[m.manA] += a;
        points[m.womanA] += a;
      }
      if (!isNaN(b)) {
        points[m.manB] += b;
        points[m.womanB] += b;
      }
    }
  });

  const all = PLAYERS.map(p => ({
    name: p.name,
    sex: p.sex,
    pts: points[p.name] || 0
  }));

  const global = [...all].sort((x,y)=> y.pts - x.pts || x.name.localeCompare(y.name));
  const men    = global.filter(p => p.sex === "H");
  const women  = global.filter(p => p.sex === "F");

  fillTable("#tableGlobal", global, true);
  fillTable("#tableMen", men, false);
  fillTable("#tableWomen", women, false);
}

function fillTable(selector, list, withSex) {
  const tbody = document.querySelector(selector + " tbody");
  tbody.innerHTML = "";
  list.forEach((p, idx) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${idx+1}</td>
      <td>${p.name}</td>
      ${withSex ? `<td>${p.sex}</td>` : ""}
      <td>${p.pts}</td>
    `;
    tbody.appendChild(tr);
  });
}

/* ==== INIT ==== */
document.addEventListener("DOMContentLoaded", () => {
  renderPlayers();
  loadMatches();
  renderRotationSelect();
  // s'il n'y a aucun match, on cr√©e quelques lignes par d√©faut pour la rotation 1
  if (matches.length === 0) {
    const defaultRot = 1;
    for (let i = 1; i <= 4; i++) {
      matches.push({
        id: nextId++,
        rotation: defaultRot,
        court: i,
        manA: "",
        womanA: "",
        manB: "",
        womanB: "",
        ptsA: "",
        ptsB: ""
      });
    }
    saveMatches();
  }
  renderMatchesTable();
  recomputeStandings();

  document.getElementById("rotationSelect").addEventListener("change", () => {
    renderMatchesTable();
  });

  document.getElementById("addMatchBtn").addEventListener("click", () => {
    const rot = Number(document.getElementById("rotationSelect").value) || 1;
    addMatchToRotation(rot);
  });

  document.getElementById("clearScoresBtn").addEventListener("click", clearAllScores);
});
</script>
</body>
</html>